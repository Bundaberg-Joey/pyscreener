import subprocess as sp
from os import PathLike
import subprocess as sp
import sys
from typing import Callable, List, Optional, Tuple, Union

# a Ligand is a tuple of a molecule's SMILES string 
# and its corresponding input file
Ligand = Tuple[str, str]

OBABEL = sp.run('which obabel', shell=True, encoding='utf-8', 
                stdout=sp.PIPE, check=True).stdout.strip()

def run_and_parse_docker(
    argv: List[str],
    parse_log: Callable[[Union[str, PathLike], str], Optional[float]], 
    log: Union[str, PathLike], score_mode: str = 'best') -> Optional[float]:
    """Run an instance of the docking program and parse the log file.

    Parameters
    ----------
    argv : List[str]
        the argument vector used to run an instance of a program
    parse_log : Callable[[Union[str, PathLike], str], Optional[float]]
        a function to parse the generated log file
    log : Union[str, PathLike]
        the filename of a log file generated by docking program or a
        PathLike object pointing to that file
    score_mode : str (Default = 'best')
        The method used to calculate the docking score from the log file.
        Choices are:
          'best' - return the top docking score
          'avg' - return the average of all the docking scores
          'boltzmann' - return the boltzmann average of all the docking scores
    Returns
    -------
    score : Optional[float]
        the score calculated from the docking run. None if docking
        run failed for any reason or generated an unparsable log file.
    """
    ret = sp.run(argv, stdout=sp.PIPE, stderr=sp.PIPE)
    try:
        ret.check_returncode()
    except sp.SubprocessError:
        print(f'ERROR: docking failed. argv: {argv}', file=sys.stderr)
        print(f'Message: {ret.stderr.decode("utf-8")}', file=sys.stderr)
        print('Skipping...', file=sys.stderr, flush=True)
        return None

    try:
        return parse_log(log, score_mode)
    except OSError:
        return None
