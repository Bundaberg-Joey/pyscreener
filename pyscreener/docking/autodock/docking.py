"""This module contains functions related to preparing and running vina-type
docking simulations"""

from itertools import takewhile
from math import exp
from pathlib import Path
from typing import List, Optional, Tuple

from pyscreener import utils

def build_vina_argv(docker: str, receptor: str, ligand: str,
                    center: Tuple[float, float, float],
                    size: Tuple[int, int, int] = (10, 10, 10),
                    ncpu: int = 1, name: Optional[str] = None,
                    path: str = '.', extra = Optional[List[str]],
                    **kwargs) -> Tuple[List[str], str, str]:
    """Builds the argument vector to run a vina-type docking program

    Parameters
    ----------
    docker : str
        the name of the docking program to run
    receptor : str
        the filename of the input receptor file
    ligand : str
        the filename of the input ligand file
    center : Tuple[float, float, float]
        the coordinates (x,y,z) of the center of the vina search box
    size : Tuple[int, int, int] (Default = (10, 10, 10))
        the size of the vina search box in angstroms for the x, y, and z-
        dimensions, respectively
    ncpu : int (Default = 1)
        the number of cores to allocate to the docking program
    name : string (Default = <receptor>_<ligand>)
        the base name to use for both the log and out files
    path : string (Default = '.')
        the path under which both the log and out files should be written
    extra : Optional[List[str]]
        additional command line arguments to pass to each vina run
    **kwargs
        additional and unused keyword arguments

    Returns
    -------
    vina_type_argv : List[str]
        the argument vector with which to run an instance of a vina-type
        docking program
    out : str
        the filepath of the out file which the docking program will write to
    log : str
        the filepath of the log file which the docking program will write to
    """
    if docker not in {'vina', 'smina', 'psovina', 'qvina'}:
        raise ValueError(f'Inappropriate docking program: "{docker}"')

    path = Path(path)
    if not path.is_dir():
        path.mkdir(parents=True)

    name = name or (Path(receptor).stem+'_' +Path(ligand).stem)
    extra = extra or []

    out = f'{path}/{docker}_{name}_out.pdbqt'
    log = f'{path}/{docker}_{name}_log.txt'
    
    vina_type_argv = [
        docker, f'--receptor={receptor}', f'--ligand={ligand}',
        f'--center_x={center[0]}',
        f'--center_y={center[1]}',
        f'--center_z={center[2]}',
        f'--size_x={size[0]}', f'--size_y={size[1]}', f'--size_z={size[2]}',
        f'--cpu={ncpu}', f'--out={out}', f'--log={log}', *extra
    ]

    return vina_type_argv, out, log

def parse_vina_log(vina_log: str, score_mode : str = 'best') -> Optional[float]:
    """Parse the log file generated from a run of Vina-type docking software
    and return the appropriate score.

    Parameters
    ----------
    vina_log : str
        the filename of a log file generated by vina-type docking program
    score_mode : str (Default = 'best')
        The method used to calculate the docking score from the log file.
        Choices: 'best', 'avg', and 'boltzmann'.
        See also: pyscreener.utils.calc_score for more details

    Returns
    -------
    score : Optional[float]
        The boltzmann average of the scores or the top score. None if the log
        file was unparsable
    """
    # vina-type log files have scoring information between this table border
    # and the line containing "Writing output ... done."
    TABLE_BORDER = '-----+------------+----------+----------'

    with open(vina_log) as fid:
        for line in fid:
            if TABLE_BORDER in line:
                break

        score_lines = takewhile(lambda line: 'Writing' not in line, fid)
        scores = [float(line.split()[1]) for line in score_lines]

    if len(scores) == 0:
        return None

    # if score_mode == 'best':
    #     score = scores[0]
    # elif score_mode == 'avg':
    #     score = sum(score for score in scores) / len(scores)
    # elif score_mode == 'boltzmann':
    #     Z = sum(exp(-score) for score in scores)
    #     score = sum(score * exp(-score) / Z for score in scores)

    return utils.calc_score(scores, score_mode)