from concurrent.futures import Executor
from functools import partial
import os
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple, Union

from tqdm import tqdm

from ..utils import run_and_parse_docker

DOCK6 = str(Path(os.environ['DOCK6']) / 'bin' / 'dock6')

def parse_log(log: Union[str, os.PathLike],
              score_mode : str = 'best') -> Optional[float]:
    """Parse the log file generated from a run of Vina-type docking software
    and return the appropriate score.

    Parameters
    ----------
    log : Union[str, PathLike]
        the filename of a log file generated by DOCK6 or a PathLike object 
        pointing to that file
    score_mode : str (Default = 'best')
        The method used to calculate the docking score from the log file.
        See also pyscreener.utils.calc_score for more details
        UNUSED FOR NOW (because we're only writing one conformer)

    Returns
    -------
    score : Optional[float]
        the parsed score given the input scoring mode or None if the log
        file was unparsable 
    """
    score_mode[0]
    
    with open(log) as fid:
        for line in fid:
            if 'Grid Score' in line:
                break
        try:
            score = float(line.split()[1])
        except:
            score = None

    return score

def dock_ligand(ligand, path: str = '.', repeats: int = 1,
                score_mode: str = 'best') -> List[List[Dict]]:
    if repeats <= 0:
        raise ValueError(f'Repeats must be greater than 0! ({repeats})')

    smi, ensemble_infiles = ligand

    ensemble_rowss = []
    for infile, outfile_prefix in ensemble_infiles:
        repeat_rows = []
        for repeat in range(repeats):
            name = f'{Path(infile).stem}__{repeat}'

            logfile = Path(path / Path(infile).with_suffix('.out'))
            argv = [DOCK6, '-i', infile, '-o', logfile]

            score = run_and_parse_docker(argv, parse_log, logfile, score_mode)

            if score:
                repeat_rows.append({
                    'smiles': smi,
                    'name': name,
                    'in': infile,
                    'log': str(logfile),
                    'out': f'{outfile_prefix}_scored.mol2',
                    'score': score
                })

        if repeat_rows:
            ensemble_rowss.append(repeat_rows)

    return ensemble_rowss

def dock_inputs(ligands: Tuple[str, List[Tuple[str, str]]], 
                path: str = '.', repeats: int = 1,
                score_mode: str = 'best',
                client: Optional[Executor] = None, 
                chunksize: int = 32) -> List[List[List[Dict]]]:
    dock_ligand_ = partial(
        dock_ligand, path=path, score_mode=score_mode, repeats=repeats
    )

    if client:
        rowsss = list(tqdm(
            client.map(dock_ligand_, ligands, chunksize=chunksize),
            total=len(ligands), smoothing=0.,
            desc='Docking ligands', unit='ligand'
        ))
    else:
        rowsss = list(tqdm(
            map(dock_ligand_, ligands, chunksize=chunksize),
            total=len(ligands), smoothing=0.,
            desc='Docking ligands', unit='ligand'
        ))

    return rowsss