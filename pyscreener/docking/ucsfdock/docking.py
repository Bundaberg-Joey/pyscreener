from concurrent.futures import Executor
from functools import partial
import os
from pathlib import Path
from typing import Dict, Iterable, List, Optional, Tuple, Union

from tqdm import tqdm

from ..utils import run_and_parse_docker
from ...utils import calc_score

DOCK6 = str(Path(os.environ['DOCK6']) / 'bin' / 'dock6')

def parse_out(outfile: Union[str, os.PathLike],
              score_mode : str = 'best') -> Optional[float]:
    """Parse the log file generated from a run of Vina-type docking software
    and return the appropriate score.

    Parameters
    ----------
    outfile : Union[str, PathLike]
        the filename of a scored outfile file generated by DOCK6 or a 
        PathLike object pointing to that file
    score_mode : str (Default = 'best')
        The method used to calculate the docking score from the outfile file.
        See also pyscreener.utils.calc_score for more details

    Returns
    -------
    score : Optional[float]
        the parsed score given the input scoring mode or None if the log
        file was unparsable 
    """
    score_mode[0]
    
    scores = []
    with open(outfile) as fid:
        for line in fid:
            if 'Grid_Score:' in line:
                try:
                    scores.append(float(line.split()[2]))
                except:
                    continue

    return calc_score(scores, score_mode)

def dock_ligand(ligand, path: str = '.', repeats: int = 1,
                score_mode: str = 'best') -> List[List[Dict]]:
    if repeats <= 0:
        raise ValueError(f'Repeats must be greater than 0! ({repeats})')

    smi, ensemble_infiles = ligand

    ensemble_rowss = []
    for infile, outfile_prefix in ensemble_infiles:
        repeat_rows = []
        for repeat in range(repeats):
            name = f'{Path(infile).stem}__{repeat}'

            log = Path(path / Path(infile).with_suffix('.out'))
            argv = [DOCK6, '-i', infile, '-o', log]

            out = f'{outfile_prefix}_scored.mol2'
            score = run_and_parse_docker(argv, parse_out, out, score_mode)

            if score:
                repeat_rows.append({
                    'smiles': smi,
                    'name': name,
                    'in': infile,
                    'log': str(log),
                    'out': out,
                    'score': score
                })

        if repeat_rows:
            ensemble_rowss.append(repeat_rows)

    return ensemble_rowss

def dock_inputs(ligands: Tuple[str, List[Tuple[str, str]]], 
                path: str = '.', repeats: int = 1,
                score_mode: str = 'best',
                client: Optional[Executor] = None, 
                chunksize: int = 32) -> List[List[List[Dict]]]:
    dock_ligand_ = partial(
        dock_ligand, path=path, score_mode=score_mode, repeats=repeats
    )

    if client:
        rowsss = list(tqdm(
            client.map(dock_ligand_, ligands, chunksize=chunksize),
            total=len(ligands), smoothing=0.,
            desc='Docking ligands', unit='ligand'
        ))
    else:
        rowsss = list(tqdm(
            map(dock_ligand_, ligands, chunksize=chunksize),
            total=len(ligands), smoothing=0.,
            desc='Docking ligands', unit='ligand'
        ))

    return rowsss