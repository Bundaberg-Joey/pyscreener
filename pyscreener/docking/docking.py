"""This module contains code for programatically performing docking
simulations and parsing the results into a mapping of ligand -> docking score"""

from collections import defaultdict
import datetime
from functools import partial
from itertools import takewhile
from math import ceil, exp
import os
from pathlib import Path
import subprocess as sp
import sys
import timeit
from typing import Dict, List, Optional, Tuple

from tqdm import tqdm

from .vina import build_vina_argv, parse_vina_log

def build_docker_argv(docker, *args, **kwargs) -> Tuple[List[str], str, str]:
    """Build the argument vector to run a docking program
    
    Parameters
    ----------
    docker : str
        the docking program for which to build an argument vector
    *args, **kwargs
        positional and keyword arguments for the relevant function
    """
    try:
        return {
            'vina': build_vina_argv,
            'psovina': build_vina_argv,
            'qvina': build_vina_argv,
            'smina': build_vina_argv,
        }[docker](docker=docker, *args, **kwargs)
    except KeyError:
        print(f'WARNING: {docker} is not a recognized docking program')
        print('Defaulting to AutoDock Vina')
        
        return build_vina_argv(docker='vina', *args, **kwargs)

# def build_vina_argv(docker: str, receptor: str, ligand: str,
#                     center: Tuple[float, float, float],
#                     size: Tuple[int, int, int] = (10, 10, 10),
#                     ncpu: int = 1, name: str = None,
#                     path: str = '.', **kwargs) -> Tuple[List[str], str, str]:
#     """Builds the argument vector to run a vina-type docking program

#     Parameters
#     ----------
#     docker : str
#         the name of the docking program to run
#     receptor : str
#         the filename of the input receptor file
#     ligand : str
#         the filename of the input ligand file
#     center : Tuple[float, float, float]
#         the coordinates (x,y,z) of the center of the vina search box
#     size : Tuple[int, int, int] (Default = (10, 10, 10))
#         the size of the vina search box in angstroms for the x, y, and z-
#         dimensions, respectively
#     ncpu : int (Default = 1)
#         the number of cores to allocate to the docking program
#     name : string (Default = <receptor>_<ligand>)
#         the base name to use for both the log and out files
#     path : string (Default = '.')
#         the path to which both the log and out files should be written to
#     **kwargs
#         unused and additional keyword arguments

#     Returns
#     -------
#     docker_argv : List[str]
#         the argument vector with which to run an instance of the specified
#         docking program
#     out : str
#         the filepath of the out file which the docking program will write to
#     log : str
#         the filepath of the log file which the docking program will write to
#     """
#     if docker not in {'vina', 'smina', 'psovina', 'qvina'}:
#         raise ValueError(f'Bad docking program specified ({docker})')

#     if receptor == '' or ligand == '':
#         raise ValueError('receptor or ligand filename was empty')
#     if not Path(receptor).exists():
#         raise ValueError('receptor file does not exist')
#     if not Path(ligand).exists():
#         raise ValueError('ligand file does not exist')

#     path = path or f'docking_results_{datetime.date.today()}'
#     p_out = Path(path)
#     if not p_out.is_dir():
#         p_out.mkdir(parents=True)

#     name = name or (Path(receptor).stem+'_' +Path(ligand).stem)
#     out = str(p_out / (name+f'_{docker}_out.pdbqt'))
#     log = str(p_out / (name+f'_{docker}_log.txt'))

#     docker_argv = [
#         docker, f'--receptor={receptor}', f'--ligand={ligand}',
#         f'--center_x={center[0]}',
#         f'--center_y={center[1]}',
#         f'--center_z={center[2]}',
#         f'--size_x={size[0]}', f'--size_y={size[1]}', f'--size_z={size[2]}',
#         f'--cpu={ncpu}', f'--out={out}', f'--log={log}'
#     ]

#     return docker_argv, out, log

def parse_log_file(docker: str, log: str,
                   boltzmann: bool = False) -> Optional[float]:
    """Returns the top docking score or average of the top n docking scores
    from a run of the specified docking program

    Parameters
    ----------
    docker : str
        the name of the docking program that generated the log file
    log : str
        the filename of the log file generated by the docking program
    boltzmann : bool (Default = False)
        whether to calculate the boltzmann average of the scores. If false,
        just return the top score

    Returns
    -------
    score : Optional[float]
        The boltzmann average of the scores or the top score. None if the log
        file was unparsable or there was an error opening the file.
    """
    try:
        return {
            'vina': parse_vina_log,
            'qvina': parse_vina_log,
            'smina': parse_vina_log,
            'psovina': parse_vina_log
        }[docker](log, boltzmann)
    except KeyError:
        raise ValueError(
            'Cannot parse log files not generated by one of the following:'
            + 'Vina, QVina, Smina, or PSOVina')
    except OSError:
        return None

# def parse_vina_log(vina_log: str, boltzmann: bool = False) -> Optional[float]:
#     """Parse the log file generated from a run of Vina-type docking software
#     and return the appropriate score.

#     Parameters
#     ----------
#     vina_log : str
#         the filename of a log file generated by vina
#     boltzmann : bool (Default = False)
#         whether to calculate the boltzmann average of the scores. If False,
#         just return the top score

#     Returns
#     -------
#     score : Optional[float]
#         The boltzmann average of the scores or the top score. None if the log
#         file was unparsable
#     """
#     # vina-type log files have scoring information between this table border
#     # and the line containing "Writing output ... done."
#     TABLE_BORDER = '-----+------------+----------+----------'

#     with open(vina_log) as fid:
#         for line in fid:
#             if TABLE_BORDER in line:
#                 break

#         score_lines = takewhile(lambda line: 'Writing' not in line, fid)
#         scores = [float(line.split()[1]) for line in score_lines]

#     if len(scores) == 0:
#         return None

#     if boltzmann:
#         Z = sum(exp(-score) for score in scores)
#         boltzmann_avg = sum(score * exp(-score) / Z for score in scores)
#         return boltzmann_avg

#     return scores[0]

def run_and_parse_docker(docker_argv: List[str], docker: str, log: str,
                         boltzmann: bool = False) -> Optional[float]:
    """Run an instance of the docking program and parse the log file.

    Parameters
    ----------
    docker_argv : List[str]
        the argument vector used to run an instance of a program
    docker : str
        the docking program that will be run
    log : str
        the filename of the log file that will be generated
    boltzmann : bool (Default = False)
        whether to return the boltzmann average of the scores or
        just the top score

    Returns
    -------
    score : Optional[float]
        the score calculated from the docking run. None if docking
        run failed for any reason or generated an unparsable log file.
    """
    try:
        sp.run(docker_argv, stdout=sp.PIPE, stderr=sp.PIPE, check=True)
    except sp.SubprocessError:
        print('ERROR: failed to dock ligand located in file',
              f'"{docker_argv[2].split("=")[1]}". Skipping...',
              file=sys.stderr)
        return None

    return parse_log_file(docker, log, boltzmann)

def dock_ligand(ligand: Tuple[str, str], docker: str, receptor: str,
                center: Tuple[float, float, float],
                size: Tuple[int, int, int] = (10, 10, 10),
                ncpu: int = 1, path: str = '.',
                boltzmann: bool = False) -> Dict:
    """Dock the given ligand using the specified docking progam and parameters
    
    Parameters
    ----------
    ligand : Tuple[str, str]
        a tuple containing a ligand's SMILES string and associated docking
        input file
    docker : str
        the docking program to run
    receptor : str
        the name of the pdbqt file corresponding to the receptor
    center : Tuple[float, float, float]
        the x-, y-, and z-coordinates, respectively, of the search box center
    size : Tuple[int, int, int] (Default = (10, 10, 10))
        the x, y, and z-radii, respectively, of the search box
    path : string (Default = '.')
        the path under which both the log and out files should be written to
    ncpu : int (Default = 1)
        the number of cores to allocate to the docking program
    boltzmann : bool (Default = False)
        whether to calculate the boltzmann average of the scores. If false,
        just return the top score
    
    Return
    ------
    row : Dict
        a row of a dataframe for this ligand's docking run containing the
        following columns
            smiles  - the ligand's SMILES string
            name    - the name of the ligand
            in      - the filepath of the input ligand file
            out     - the filepath of the output docked ligand
            log     - the filepath of the log file
            score   - the ligand's docking score
    """
    smi, pdbqt = ligand
    
    docker_argv, out, log = build_docker_argv(
        docker, receptor=receptor, ligand=pdbqt,
        center=center, size=size, ncpu=ncpu, path=path
    )

    return {
        'smiles': smi,
        'name': Path(pdbqt).stem,
        'in': pdbqt,
        'out': out,
        'log': log,
        'score': run_and_parse_docker(docker_argv, docker, log, boltzmann)
    }

def dock_ligands(ligands: List[Tuple[str, str]], docker: str, receptor: str, 
                 center: Tuple[float, float, float],
                 size: Tuple[int, int, int] = (10, 10, 10), ncpu: int = 4,
                 path: str = './docking_results_'+str(datetime.date.today()),
                 boltzmann: bool = False, 
                 distributed: bool = True, nworkers: int = -1,
                 verbose: int = 0,
                 **kwargs) -> Tuple[Dict[str, Optional[float]], List[Dict]]:
    """Run the specified docking program with the input ligands and parameters

    Parameters
    ----------
    ligands : List[Tuple[string, string]]
        a list of tuples containing the SMILES string and the input filename
        for all ligands to be screened
    docker : str
    receptor : str
    center : Tuple[float, float, float]
    size : Tuple[int, int, int] (Default = (10, 10, 10))
    path : string (Default = './docking_results_YYYY-MM-DD/')
    boltzmann : bool (Default = False)
        see dock_ligand() for parameter documentation
    distributed: bool (Default = True)
        whether the work should be performed over a distributed system. 
        Setting this value to false will result in all simulations being
        performed on the local machine
    ncpu : int (Default = 1)
        the number of cores to available to each worker
    nworkers : int (Default = -1)
        the number of workers to distribute docking simulations over. A value
        of -1 will use all available cores. This argument only needs to be set
        if distributed is False.
    verbose : int (Default = 0)
        whether or not to print performance data

    Returns
    -------
    d_smi_score : Dict[str, float]
        a dictionary mapping SMILES string to the best score among the
        corresponding ligands. Does not include ligands for which all
        inputs failed to dock.
    rows : List[Dict]
        A dataframe containing the following information for each 
        docking run:
            smiles  - the ligand's SMILES string
            name    - the name of the ligand
            in      - the filepath of the input ligand file
            out     - the filepath of the output docked ligand
            log     - the filepath of the log file
            score   - the ligand's docking score
    """
    begin = timeit.default_timer()

    if distributed:
        from mpi4py import MPI
        from mpi4py.futures import MPIPoolExecutor as Pool

        n_workers = MPI.COMM_WORLD.size
    else:
        from concurrent.futures import ProcessPoolExecutor as Pool
        if n_workers == -1:
            try:
                n_workers = len(os.sched_getaffinity(0)) // ncpu
            except AttributeError:
                n_workers = os.cpu_count()

    BATCHES_PER_PROCESS = 32
    batch_size = ceil(len(ligands) / (BATCHES_PER_PROCESS*n_workers))

    with Pool(max_workers=n_workers) as client:
        dock_ligand_partial = partial(
            dock_ligand, docker=docker, receptor=receptor,
            center=center, size=size, ncpu=ncpu, path=path, boltzmann=boltzmann
        )
        rows = client.map(dock_ligand_partial, ligands, chunksize=batch_size)
        rows = list(tqdm(rows, total=len(ligands), smoothing=0.,
                    desc='Docking ligands', unit='ligand'))
    
    # record only the top-scoring conformation/tautomer
    d_smi_score = defaultdict(lambda: float('inf'))
    for row in rows:
        smi = row['smiles']
        score = row['score']
        if score is None:
            continue
        curr_score = d_smi_score[smi]
        d_smi_score[smi] = min(curr_score, score)
    d_smi_score = dict(d_smi_score)

    total = timeit.default_timer() - begin
    m, s = divmod(int(total), 60)
    h, m = divmod(m, 60)
    if verbose > 0 and len(ligands) > 0:
        print(f'  Time to dock {len(ligands)} ligands:',
              f'{h:d}h {m:d}m {s:d}s', flush=True)
        print(f'  Average: {total/len(ligands):0.3f} s/ligand', flush=True)

    return d_smi_score, rows
