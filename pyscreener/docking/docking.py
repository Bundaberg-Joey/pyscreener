"""This module contains code for programatically performing docking
simulations and parsing the results into a mapping of ligand -> docking score"""

from collections import defaultdict
import datetime
from functools import partial
from itertools import takewhile
from math import ceil, exp
import os
from pathlib import Path
import subprocess as sp
import sys
import timeit
from typing import Dict, List, Optional, NewType, Tuple

from tqdm import tqdm

from .autodock import build_vina_argv, parse_vina_log
from pyscreener import utils

Ligand = Tuple[str, str]

def dock(inputs: Tuple[List[str], List[Ligand]], **kwargs):
    kwargs['receptors'], kwargs['ligands'] = inputs
    return dock_ligands(**kwargs)

def build_docker_argv(docker, *args, **kwargs) -> Tuple[List[str], str, str]:
    """Build the argument vector to run a docking program
    
    Parameters
    ----------
    docker : str
        Choices = {'vina', 'psovina', 'qvina', 'smina'}
        the docking program for which to build an argument vector. Specifying
        a docking program not in the recognized list will default to using vina.
    *args, **kwargs
        positional and keyword arguments for the relevant function
    """
    try:
        return {
            'vina': build_vina_argv,
            'psovina': build_vina_argv,
            'qvina': build_vina_argv,
            'smina': build_vina_argv,
        }[docker](docker=docker, *args, **kwargs)
    except KeyError:
        print(f'WARNING: Unrecognized docking program: "{docker}"')
        print('Defaulting to AutoDock Vina')
        return build_vina_argv(docker='vina', *args, **kwargs)

def parse_log_file(docker: str, log: str,
                   score_mode : str = 'best') -> Optional[float]:
    """Returns the top docking score or average of the top n docking scores
    from a run of the specified docking program

    Parameters
    ----------
    docker : str
        Choices = {'vina', 'psovina', 'qvina', 'smina'}
        the name of the docking program that generated the log file. Specifying
        a docking program not in the recognized list will result in the file
        attempting to be parsed as an autodock-type log file.
    log : str
        the filename of the log file generated by the docking program
    score_mode : str (Default = 'best')
        The method used to calculate the docking score from the log file.
        Choices are:
            'best' - return the top docking score
            'avg' - return the average of all the docking scores
            'boltzmann' - return the boltzmann average of all the docking scores

    Returns
    -------
    score : Optional[float]
        The boltzmann average of the scores or the top score. None if the log
        file was unparsable or there was an error opening the file.
    """
    try:
        return {
            'vina': parse_vina_log,
            'qvina': parse_vina_log,
            'smina': parse_vina_log,
            'psovina': parse_vina_log
        }[docker](log, score_mode)
    except KeyError:
        print(f'WARNING: Unrecognized docking program: "{docker}"')
        print('Attempting to parse as AutoDock-type log')
        return parse_vina_log(log, score_mode)
    except OSError:
        return None

def run_and_parse_docker(docker_argv: List[str], docker: str, log: str,
                         score_mode: str = 'best') -> Optional[float]:
    """Run an instance of the docking program and parse the log file.

    Parameters
    ----------
    docker_argv : List[str]
        the argument vector used to run an instance of a program
    docker : str
        the docking program that will be run
    log : str
        the filename of the log file that will be generated
    score_mode : str (Default = 'best')
        see parse_log_file for parameter documentation

    Returns
    -------
    score : Optional[float]
        the score calculated from the docking run. None if docking
        run failed for any reason or generated an unparsable log file.
    """
    try:
        sp.run(docker_argv, stdout=sp.PIPE, stderr=sp.PIPE, check=True)
    except sp.SubprocessError:
        print('ERROR: failed to dock ligand located in file',
              f'"{docker_argv[2].split("=")[1]}". Skipping...',
              file=sys.stderr, flush=True)
        return None

    return parse_log_file(docker, log, score_mode)

def dock_ligand(ligand: Ligand, docker: str, receptors: List[str],
                center: Tuple[float, float, float],
                size: Tuple[int, int, int] = (10, 10, 10), ncpu: int = 1, 
                path: str = '.', extra: Optional[List[str]] = None,
                score_mode: str = 'best',
                repeats: int = 1, repeat_score_mode: str = 'best') -> Dict:
    """Dock the given ligand using the specified docking progam and parameters
    into the ensemble of receptors
    
    Parameters
    ----------
    ligand : Ligand
        a tuple containing a ligand's SMILES string and associated docking
        input file
    docker : str
        the docking program to run
    receptors : List[str]
        the name of the pdbqt file corresponding to the receptor
    center : Tuple[float, float, float]
        the x-, y-, and z-coordinates, respectively, of the search box center
    size : Tuple[int, int, int] (Default = (10, 10, 10))
        the x, y, and z-radii, respectively, of the search box
    path : string (Default = '.')
        the path under which both the log and out files should be written to
    ncpu : int (Default = 1)
        the number of cores to allocate to the docking program
    score_mode : str (Default = 'best')
        the method used to calculate the docking score of an individual
        docking run
    repeats : int (Deafult = 1)
        the number of times to repeat a docking run
    repeat_score_mode : str (Default = 'best')
        the method used to calculate the overall docking score of a molecule
        for repeated runs
    ensemble_score_mode : str (Default = 'best')
        the method by which to calculate the overall docking score of a
        molecule in an ensemble of docking runs (multiple structures)

    Return
    ------
    row : Dict
        a row of a dataframe for this ligand's docking run containing the
        following columns
            smiles  - the ligand's SMILES string
            name    - the name of the ligand
            in      - the filename of the input ligand file
            out     - the filename of the output docked ligand file
            log     - the filename of the log file
            score   - the ligand's docking score
    """
    if repeats <= 0:
        raise ValueError(f'Repeats must be greater than 0! ({repeats})')

    smi, pdbqt = ligand
    
    ensemble_scores = []
    for receptor in receptors:
        docker_argv, out, log = build_docker_argv(
            docker, receptor=receptor, ligand=pdbqt,
            center=center, size=size, ncpu=ncpu, extra=extra, path=path
        )

        repeat_scores = [
            run_and_parse_docker(docker_argv, docker, log, score_mode)
            for _ in range(repeats)
        ]
        repeat_scores = [score for score in repeat_scores if score is not None]
        if repeat_scores:
            ensemble_scores.append(utils.calc_score(repeat_scores,
                                                    repeat_score_mode))

    if ensemble_scores:
        score = utils.calc_score(ensemble_scores, repeat_score_mode)
    else:
        score = None

    p_in = Path(pdbqt)
    p_out = Path(out)
    p_log = Path(log)

    return {
        'smiles': smi,
        'name': Path(pdbqt).stem,
        'in': f'{p_in.parent.name} / {p_in.name}',
        'out': f'{p_out.parent.name} / {p_out.name}',
        'log': f'{p_log.parent.name} / {p_log.name}',
        'score': score
    }

def dock_ligands(ligands: List[Ligand], docker: str, receptors: List[str], 
                 center: Tuple[float, float, float],
                 size: Tuple[int, int, int] = (10, 10, 10), ncpu: int = 4,
                 path: str = './docking_results_'+str(datetime.date.today()),
                 score_mode: str = 'best', repeats: int = 1,
                 distributed: bool = True, nworkers: int = -1,
                 verbose: int = 0,
                 **kwargs) -> Tuple[Dict[str, Optional[float]], List[Dict]]:
    """Run the specified docking program with the input ligands and parameters

    Parameters
    ----------
    ligands : List[Tuple[string, string]]
        a list of tuples containing the SMILES string and the input filename
        for all ligands to be screened
    docker : str
    receptor : str
    center : Tuple[float, float, float]
    size : Tuple[int, int, int] (Default = (10, 10, 10))
    path : string (Default = './docking_results_YYYY-MM-DD/')
    score_mode : str (Default = 'best')
    repeats : int (Default = 1)
        see dock_ligand() for parameter documentation
    distributed: bool (Default = True)
        whether the work should be performed over a distributed system. 
        Setting this value to false will result in all simulations being
        performed on the local machine
    ncpu : int (Default = 1)
        the number of cores to available to each worker
    nworkers : int (Default = -1)
        the number of workers to distribute docking simulations over. A value
        of -1 will use all available cores. This argument only needs to be set
        if distributed is False.
    verbose : int (Default = 0)
        whether or not to print performance data

    Returns
    -------
    d_smi_score : Dict[str, float]
        a dictionary mapping SMILES string to the best score among the
        corresponding ligands. Does not include ligands for which all
        inputs failed to dock.
    rows : List[Dict]
        A dataframe containing the following information for each 
        docking run:
            smiles  - the ligand's SMILES string
            name    - the name of the ligand
            in      - the filepath of the input ligand file
            out     - the filepath of the output docked ligand
            log     - the filepath of the log file
            score   - the ligand's docking score
    """
    begin = timeit.default_timer()

    if distributed:
        from mpi4py import MPI
        from mpi4py.futures import MPIPoolExecutor as Pool

        n_workers = MPI.COMM_WORLD.size
    else:
        from concurrent.futures import ProcessPoolExecutor as Pool
        if n_workers == -1:
            try:
                n_workers = len(os.sched_getaffinity(0)) // ncpu
            except AttributeError:
                n_workers = os.cpu_count()

    BATCHES_PER_PROCESS = 32
    batch_size = ceil(len(ligands) / (BATCHES_PER_PROCESS*n_workers))

    with Pool(max_workers=n_workers) as client:
        dock_ligand_partial = partial(
            dock_ligand, docker=docker, receptors=receptors,
            center=center, size=size, ncpu=ncpu, path=path,
            score_mode=score_mode, repeats=repeats
        )
        rows = client.map(dock_ligand_partial, ligands, chunksize=batch_size)
        rows = list(tqdm(rows, total=len(ligands), smoothing=0.,
                    desc='Docking ligands', unit='ligand'))
    
    # record only the top-scoring conformation/tautomer
    d_smi_score = defaultdict(lambda: float('inf'))
    for row in rows:
        smi = row['smiles']
        score = row['score']
        if score is None:
            continue
        curr_score = d_smi_score[smi]
        d_smi_score[smi] = min(curr_score, score)
    d_smi_score = dict(d_smi_score)

    total = timeit.default_timer() - begin
    m, s = divmod(int(total), 60)
    h, m = divmod(m, 60)
    if verbose > 0 and len(ligands) > 0:
        print(f'  Time to dock {len(ligands)} ligands:',
              f'{h:d}h {m:d}m {s:d}s ({total/len(ligands):0.3f} s/ligand)', 
              flush=True)
              
    return d_smi_score, rows
